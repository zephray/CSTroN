#NET AUDIO_SDATA_OUT LOC = AG16;
#NET AUDIO_BIT_CLK LOC = AF18;
#NET AUDIO_BIT_CLK TNM_NET = AUDIO_BIT_CLK;
#TIMESPEC TS_AUDIO_BIT_CLK = PERIOD AUDIO_BIT_CLK 12.288MHz HIGH 50%;
#NET AUDIO_SDATA_IN LOC = AE18;
#NET AUDIO_SYNC LOC = AF19;
#NET AUDIO* IOSTANDARD = LVCMOS33;
#NET FLASH_AUDIO_RESET_B LOC = AG17;
##
#NET SRAM_FLASH_A<0> LOC = K12;
#NET SRAM_FLASH_A<1> LOC = K13;
#NET SRAM_FLASH_A<2> LOC = H23;
#NET SRAM_FLASH_A<3> LOC = G23;
#NET SRAM_FLASH_A<4> LOC = H12;
#NET SRAM_FLASH_A<5> LOC = J12;
#NET SRAM_FLASH_A<6> LOC = K22;
#NET SRAM_FLASH_A<7> LOC = K23;
#NET SRAM_FLASH_A<8> LOC = K14;
#NET SRAM_FLASH_A<9> LOC = L14;
#NET SRAM_FLASH_A<10> LOC = H22;
#NET SRAM_FLASH_A<11> LOC = G22;
#NET SRAM_FLASH_A<12> LOC = J15;
#NET SRAM_FLASH_A<13> LOC = K16;
#NET SRAM_FLASH_A<14> LOC = K21;
#NET SRAM_FLASH_A<15> LOC = J22;
#NET SRAM_FLASH_A<16> LOC = L16;
#NET SRAM_FLASH_A<17> LOC = L15;
#NET SRAM_FLASH_A<18> LOC = L20;
#NET SRAM_FLASH_A<19> LOC = L21;
#NET SRAM_FLASH_A<20> LOC = AE23;
#NET SRAM_FLASH_A<21> LOC = AE22;
#
#NET SRAM_FLASH_D<0> LOC = AD19;
#NET SRAM_FLASH_D<1> LOC = AE19;
#NET SRAM_FLASH_D<2> LOC = AE17;
#NET SRAM_FLASH_D<3> LOC = AF16;
#NET SRAM_FLASH_D<4> LOC = AD20;
#NET SRAM_FLASH_D<5> LOC = AE21;
#NET SRAM_FLASH_D<6> LOC = AE16;
#NET SRAM_FLASH_D<7> LOC = AF15;
#NET SRAM_FLASH_D<8> LOC = AH13;
#NET SRAM_FLASH_D<9> LOC = AH14;
#NET SRAM_FLASH_D<10> LOC = AH19;
#NET SRAM_FLASH_D<11> LOC = AH20;
#NET SRAM_FLASH_D<12> LOC = AG13;
#NET SRAM_FLASH_D<13> LOC = AH12;
#NET SRAM_FLASH_D<14> LOC = AH22;
#NET SRAM_FLASH_D<15> LOC = AG22;
#NET SRAM_D<16> LOC = N10;
#NET SRAM_D<17> LOC = E13;
#NET SRAM_D<18> LOC = E12;
#NET SRAM_D<19> LOC = L9;
#NET SRAM_D<20> LOC = M10;
#NET SRAM_D<21> LOC = E11;
#NET SRAM_D<22> LOC = F11;
#NET SRAM_D<23> LOC = L8;
#NET SRAM_D<24> LOC = M8;
#NET SRAM_D<25> LOC = G12;
#NET SRAM_D<26> LOC = G11;
#NET SRAM_D<27> LOC = C13;
#NET SRAM_D<28> LOC = B13;
#NET SRAM_D<29> LOC = K9;
#NET SRAM_D<30> LOC = K8;
#NET SRAM_D<31> LOC = J9;
#
#NET SRAM_DQP<0> LOC = D12;
#NET SRAM_DQP<1> LOC = C12;
#NET SRAM_DQP<2> LOC = H10;
#NET SRAM_DQP<3> LOC = H9;
#
#NET SRAM_BW<0> LOC = D10;
#NET SRAM_BW<1> LOC = D11;
#NET SRAM_BW<2> LOC = J11;
#NET SRAM_BW<3> LOC = K11;
#
#NET SRAM_FLASH_WE_B LOC = AF20;
#NET SRAM_CLK LOC = AG21;
#NET SRAM_CS_B LOC = J10;
#NET SRAM_OE_B LOC = B12;
#NET SRAM_MODE LOC = A13;
#NET SRAM_ADV_LD_B LOC = H8;
#NET FLASH_CE_B LOC = AE14;
#NET FLASH_OE_B LOC = AF14;
#NET FLASH_CLK LOC = N9;
#NET FLASH_ADV_B LOC = F13;
#NET FLASH_WAIT LOC = G13;
#NET SRAM* IOSTANDARD = LVCMOS33;
#NET FLASH* IOSTANDARD = LVCMOS33;

#NET ROTARY_INCA LOC = AH30;
#NET ROTARY_INCB LOC = AG30;
#NET ROTARY* IOSTANDARD = SSTL18_II;

#NET FPGA_SERIAL1_TX LOC = AG20;
#NET FPGA_SERIAL1_RX LOC = AG15;
#NET FPGA_SERIAL2_TX LOC = F10;
#NET FPGA_SERIAL2_RX LOC = G10;
#NET FPGA_SERIAL* IOSTANDARD = LVCMOS33;

#NET IIC_SCL_MAIN LOC = F9;
#NET IIC_SCL_MAIN IOSTANDARD = LVCMOS33;
#NET IIC_SDA_MAIN LOC = F8;
#NET IIC_SDA_MAIN IOSTANDARD = LVCMOS33;
#NET IIC_SCL_VIDEO LOC = U27;
#NET IIC_SCL_VIDEO IOSTANDARD = SSTL18_II;
#NET IIC_SDA_VIDEO LOC = T29;
#NET IIC_SDA_VIDEO IOSTANDARD = SSTL18_II;
#NET IIC_SCL_SFP LOC = R26;
#NET IIC_SCL_SFP IOSTANDARD = SSTL18_II;
#NET IIC_SDA_SFP LOC = U28;
#NET IIC_SDA_SFP IOSTANDARD = SSTL18_II;

#NET KEYBOARD_CLK LOC = T26;
#NET KEYBOARD_DATA LOC = T25;
#NET KEYBOARD* IOSTANDARD = SSTL18_II;
#NET MOUSE_CLK LOC = R27;
#NET MOUSE_DATA LOC = U26;
#NET MOUSE* IOSTANDARD = SSTL18_II;
#
#NET VGA_IN_DATA_CLK LOC = AH18;
#NET VGA_IN_BLUE<0> LOC = AC4;
#NET VGA_IN_BLUE<1> LOC = AC5;
#NET VGA_IN_BLUE<2> LOC = AB6;
#NET VGA_IN_BLUE<3> LOC = AB7;
#NET VGA_IN_BLUE<4> LOC = AA5;
#NET VGA_IN_BLUE<5> LOC = AB5;
#NET VGA_IN_BLUE<6> LOC = AC7;
#NET VGA_IN_BLUE<7> LOC = AD7;
#NET VGA_IN_GREEN<0> LOC = Y8;
#NET VGA_IN_GREEN<1> LOC = Y9;
#NET VGA_IN_GREEN<2> LOC = AD4;
#NET VGA_IN_GREEN<3> LOC = AD5;
#NET VGA_IN_GREEN<4> LOC = AA6;
#NET VGA_IN_GREEN<5> LOC = Y7;
#NET VGA_IN_GREEN<6> LOC = AD6;
#NET VGA_IN_GREEN<7> LOC = AE6;
#NET VGA_IN_RED<0> LOC = AG5;
#NET VGA_IN_RED<1> LOC = AF5;
#NET VGA_IN_RED<2> LOC = W7;
#NET VGA_IN_RED<3> LOC = V7;
#NET VGA_IN_RED<4> LOC = AH5;
#NET VGA_IN_RED<5> LOC = AG6;
#NET VGA_IN_RED<6> LOC = Y11;
#NET VGA_IN_RED<7> LOC = W11;
#NET VGA_IN_HSOUT LOC = AE7;
#NET VGA_IN_ODD_EVEN_B LOC = W6;
#NET VGA_IN_SOGOUT LOC = AF6;
#NET VGA_IN_VSOUT LOC = Y6;
#NET VGA* IOSTANDARD = LVCMOS33;

NET GPIO_SW_C LOC = AJ6;
NET GPIO_SW_E LOC = AK7;
NET GPIO_SW_N LOC = U8;
NET GPIO_SW_S LOC = V8;
NET GPIO_SW_W LOC = AJ7;
NET GPIO_SW_* IOSTANDARD = LVCMOS33;

#NET GPIO_DIP_SW<0> LOC=U25;
#NET GPIO_DIP_SW<1> LOC=AG27;
#NET GPIO_DIP_SW<2> LOC=AF25;
#NET GPIO_DIP_SW<3> LOC=AF26;
#NET GPIO_DIP_SW<4> LOC=AE27;
#NET GPIO_DIP_SW<5> LOC=AE26;
#NET GPIO_DIP_SW<6> LOC=AC25;
#NET GPIO_DIP_SW<7> LOC=AC24;
#NET GPIO_DIP_SW* IOSTANDARD = SSTL18_II;

NET GPIO_LED<0> LOC = H18;
NET GPIO_LED<0> IOSTANDARD = SSTL18_II;
NET GPIO_LED<1> LOC = L18;
NET GPIO_LED<1> IOSTANDARD = SSTL18_II;
NET GPIO_LED<2> LOC = G15;
NET GPIO_LED<2> IOSTANDARD = SSTL18_II;
NET GPIO_LED<3> LOC = AD26;
NET GPIO_LED<3> IOSTANDARD = SSTL18_II;
NET GPIO_LED<4> LOC = G16;
NET GPIO_LED<4> IOSTANDARD = SSTL18_II;
NET GPIO_LED<5> LOC = AD25;
NET GPIO_LED<5> IOSTANDARD = SSTL18_II;
NET GPIO_LED<6> LOC = AD24;
NET GPIO_LED<6> IOSTANDARD = SSTL18_II;
NET GPIO_LED<7> LOC = AE24;
NET GPIO_LED<7> IOSTANDARD = SSTL18_II;

#NET GPIO_LED_C LOC = E8;
#NET GPIO_LED_W LOC = AF23;
#NET GPIO_LED_E LOC = AG23;
#NET GPIO_LED_N LOC = AF13;
#NET GPIO_LED_S LOC = AG12;
#NET GPIO_LED_* IOSTANDARD = LVCMOS33;

NET DDR2_D<0> LOC = AF30;
NET DDR2_D<1> LOC = AK31;
NET DDR2_D<2> LOC = AF31;
NET DDR2_D<3> LOC = AD30;
NET DDR2_D<4> LOC = AJ30;
NET DDR2_D<5> LOC = AF29;
NET DDR2_D<6> LOC = AD29;
NET DDR2_D<7> LOC = AE29;
NET DDR2_D<8> LOC = AH27;
NET DDR2_D<9> LOC = AF28;
NET DDR2_D<10> LOC = AH28;
NET DDR2_D<11> LOC = AA28;
NET DDR2_D<12> LOC = AG25;
NET DDR2_D<13> LOC = AJ26;
NET DDR2_D<14> LOC = AG28;
NET DDR2_D<15> LOC = AB28;
NET DDR2_D<16> LOC = AC28;
NET DDR2_D<17> LOC = AB25;
NET DDR2_D<18> LOC = AC27;
NET DDR2_D<19> LOC = AA26;
NET DDR2_D<20> LOC = AB26;
NET DDR2_D<21> LOC = AA24;
NET DDR2_D<22> LOC = AB27;
NET DDR2_D<23> LOC = AA25;
NET DDR2_D<24> LOC = AC29;
NET DDR2_D<25> LOC = AB30;
NET DDR2_D<26> LOC = W31;
NET DDR2_D<27> LOC = V30;
NET DDR2_D<28> LOC = AC30;
NET DDR2_D<29> LOC = W29;
NET DDR2_D<30> LOC = V27;
NET DDR2_D<31> LOC = W27;
NET DDR2_D<32> LOC = V29;
NET DDR2_D<33> LOC = Y27;
NET DDR2_D<34> LOC = Y26;
NET DDR2_D<35> LOC = W24;
NET DDR2_D<36> LOC = V28;
NET DDR2_D<37> LOC = W25;
NET DDR2_D<38> LOC = W26;
NET DDR2_D<39> LOC = V24;
NET DDR2_D<40> LOC = R24;
NET DDR2_D<41> LOC = P25;
NET DDR2_D<42> LOC = N24;
NET DDR2_D<43> LOC = P26;
NET DDR2_D<44> LOC = T24;
NET DDR2_D<45> LOC = N25;
NET DDR2_D<46> LOC = P27;
NET DDR2_D<47> LOC = N28;
NET DDR2_D<48> LOC = M28;
NET DDR2_D<49> LOC = L28;
NET DDR2_D<50> LOC = F25;
NET DDR2_D<51> LOC = H25;
NET DDR2_D<52> LOC = K27;
NET DDR2_D<53> LOC = K28;
NET DDR2_D<54> LOC = H24;
NET DDR2_D<55> LOC = G26;
NET DDR2_D<56> LOC = G25;
NET DDR2_D<57> LOC = M26;
NET DDR2_D<58> LOC = J24;
NET DDR2_D<59> LOC = L26;
NET DDR2_D<60> LOC = J27;
NET DDR2_D<61> LOC = M25;
NET DDR2_D<62> LOC = L25;
NET DDR2_D<63> LOC = L24;
NET DDR2_D* IOSTANDARD = SSTL18_II_DCI;

NET DDR2_DM<0> LOC = AJ31;
NET DDR2_DM<1> LOC = AE28;
NET DDR2_DM<2> LOC = Y24;
NET DDR2_DM<3> LOC = Y31;
NET DDR2_DM<4> LOC = V25;
NET DDR2_DM<5> LOC = P24;
NET DDR2_DM<6> LOC = F26;
NET DDR2_DM<7> LOC = J25;
NET DDR2_DM* IOSTANDARD = SSTL18_II_DCI;

NET DDR2_A<0> LOC = L30;
NET DDR2_A<1> LOC = M30;
NET DDR2_A<2> LOC = N29;
NET DDR2_A<3> LOC = P29;
NET DDR2_A<4> LOC = K31;
NET DDR2_A<5> LOC = L31;
NET DDR2_A<6> LOC = P31;
NET DDR2_A<7> LOC = P30;
NET DDR2_A<8> LOC = M31;
NET DDR2_A<9> LOC = R28;
NET DDR2_A<10> LOC = J31;
NET DDR2_A<11> LOC = R29;
NET DDR2_A<12> LOC = T31;
NET DDR2_A* IOSTANDARD = SSTL18_II;

NET DDR2_CLK_P<0> LOC = AK29;
NET DDR2_CLK_N<0> LOC = AJ29;
NET DDR2_CLK_P<1> LOC = E28;
NET DDR2_CLK_N<1> LOC = F28;
NET DDR2_CLK_P* IOSTANDARD = DIFF_SSTL18_II;
NET DDR2_CLK_N* IOSTANDARD = DIFF_SSTL18_II;

NET DDR2_CS_B<0> LOC = L29;
#NET DDR2_CS_B<1> LOC = J29;
NET DDR2_CS_B* IOSTANDARD = SSTL18_II;

NET DDR2_CKE<0> LOC = T28;
#NET DDR2_CKE<1> LOC = U30;
NET DDR2_CKE* IOSTANDARD = SSTL18_II;

NET DDR2_ODT<0> LOC = F31;
#NET DDR2_ODT<1> LOC = F30;
NET DDR2_ODT* IOSTANDARD = SSTL18_II;

NET DDR2_RAS_B LOC = H30;
NET DDR2_RAS_B IOSTANDARD = SSTL18_II;
NET DDR2_CAS_B LOC = E31;
NET DDR2_CAS_B IOSTANDARD = SSTL18_II;
NET DDR2_WE_B LOC = K29;
NET DDR2_WE_B IOSTANDARD = SSTL18_II;

NET DDR2_BA<0> LOC = G31;
NET DDR2_BA<1> LOC = J30;
NET DDR2_BA* IOSTANDARD = SSTL18_II;

NET DDR2_DQS_P<0> LOC = AA29;
NET DDR2_DQS_N<0> LOC = AA30;
NET DDR2_DQS_P<1> LOC = AK28;
NET DDR2_DQS_N<1> LOC = AK27;
NET DDR2_DQS_P<2> LOC = AK26;
NET DDR2_DQS_N<2> LOC = AJ27;
NET DDR2_DQS_P<3> LOC = AB31;
NET DDR2_DQS_N<3> LOC = AA31;
NET DDR2_DQS_P<4> LOC = Y28;
NET DDR2_DQS_N<4> LOC = Y29;
NET DDR2_DQS_P<5> LOC = E26;
NET DDR2_DQS_N<5> LOC = E27;
NET DDR2_DQS_P<6> LOC = H28;
NET DDR2_DQS_N<6> LOC = G28;
NET DDR2_DQS_P<7> LOC = G27;
NET DDR2_DQS_N<7> LOC = H27;
NET DDR2_DQS_P* IOSTANDARD = DIFF_SSTL18_II_DCI;
NET DDR2_DQS_N* IOSTANDARD = DIFF_SSTL18_II_DCI;

#NET DDR2_SCL LOC = E29;
#NET DDR2_SCL IOSTANDARD = SSTL18_II;
#NET DDR2_SDA LOC = F29;
#NET DDR2_SCL IOSTANDARD = SSTL18_II;

#NET PIEZO_SPEAKER LOC = G30;
#NET PIEZO_SPEAKER IOSTANDARD = SSTL18_II;
#
#NET DVI_D<0> LOC = AB8;
#NET DVI_D<1> LOC = AC8;
#NET DVI_D<2> LOC = AN12;
#NET DVI_D<3> LOC = AP12;
#NET DVI_D<4> LOC = AA9;
#NET DVI_D<5> LOC = AA8;
#NET DVI_D<6> LOC = AM13;
#NET DVI_D<7> LOC = AN13;
#NET DVI_D<8> LOC = AA10;
#NET DVI_D<9> LOC = AB10;
#NET DVI_D<10> LOC = AP14;
#NET DVI_D<11> LOC = AN14;
#NET DVI_DE LOC = AE8;
#NET DVI_H LOC = AM12;
#NET DVI_RESET_B LOC = AK6;
#NET DVI_V LOC = AM11;
#NET DVI_XCLK_N LOC = AL10;
#NET DVI_XCLK_P LOC = AL11;
#NET DVI_* IOSTANDARD = LVCMOS33;
#NET DVI_GPIO1 LOC = N30;
#NET DVI_GPIO1 IOSTANDARD = SSTL18_II;

# Addon board
#NET DS2_DAT LOC = K32;
#NET DS2_CMD LOC = K33;
#NET DS2_ATT LOC = N32;
#NET DS2_CLK LOC = P32;
#NET DS2_ACK LOC = R34;
#NET DS2_* IOSTANDARD = LVCMOS33;

NET CSTN_XCK LOC = AJ32;
NET CSTN_LP LOC = AK33;
NET CSTN_DISPOFF LOC = AK34;
NET CSTN_FLM LOC = AH32;
NET CSTN_LD<0> LOC = AA34;
NET CSTN_LD<1> LOC = AD32;
NET CSTN_LD<2> LOC = Y34;
NET CSTN_LD<3> LOC = Y32;
NET CSTN_LD<4> LOC = W32;
NET CSTN_LD<5> LOC = AH34;
NET CSTN_LD<6> LOC = AE32;
NET CSTN_LD<7> LOC = AG32;
NET CSTN_UD<0> LOC = AK32;
NET CSTN_UD<1> LOC = AL34;
NET CSTN_UD<2> LOC = AL33;
NET CSTN_UD<3> LOC = AM33;
NET CSTN_UD<4> LOC = AJ34;
NET CSTN_UD<5> LOC = AM32;
NET CSTN_UD<6> LOC = AN34;
NET CSTN_UD<7> LOC = AN33;
NET CSTN_* IOSTANDARD = LVCMOS33;

NET FPGA_CPU_RESET_B LOC = E9;
NET FPGA_CPU_RESET_B IOSTANDARD = LVCMOS33;

NET CLK_33MHZ_FPGA LOC = AH17;
NET CLK_33MHZ_FPGA IOSTANDARD = LVCMOS33;

#NET CLK_27MHZ_FPGA LOC = AG18;
#NET CLK_27MHZ_FPGA IOSTANDARD = LVCMOS33;

#NET CLK_33MHZ_FPGA TNM_NET = CLK_33MHZ_FPGA;
#TIMESPEC TS_33M_CLK = PERIOD CLK_33MHZ_FPGA 30.0 ns HIGH 50%;

#NET CLK_27MHZ_FPGA TNM_NET = CLK_27MHZ_FPGA;
#TIMESPEC TS_27M_CLK = PERIOD CLK_27MHZ_FPGA 37.0 ns HIGH 50%;


#NET "clk_125" TNM_NET = "SYS_clk0";
#TIMESPEC "TS_SYS_clk0" = PERIOD "SYS_clk0" 8 ns HIGH 50 %;
#
#NET "clk_125_90" TNM_NET = "SYS_clk90";
#TIMESPEC "TS_SYS_clk90" = PERIOD "SYS_clk90" "TS_SYS_clk0" PHASE 2 ns HIGH 50 %;
#
#NET "clk_62p5" TNM_NET = "SYS_clkdiv0";
#TIMESPEC "TS_SYS_clkdiv0" = PERIOD "SYS_clkdiv0" "TS_SYS_clk0" * 2 HIGH 50 %;
#
#NET "clk_200" TNM_NET = "SYS_clk200";
#TIMESPEC "TS_SYS_clk200" = PERIOD "SYS_clk200" 5 ns HIGH 50 %;

###############################################################################
# Define multicycle paths - these paths may take longer because additional
# time allowed for logic to settle in calibration/initialization FSM
###############################################################################

## MIG 2.1: Eliminate Timegroup definitions for CLK0, and CLK90. Instead trace
##          multicycle paths from originating flip-flop to ANY destination
##          flip-flop (or in some cases, it can also be a BRAM)
## MUX Select for either rising/falling CLK0 for 2nd stage read capture
#INST "*/u_phy_calib/gen_rd_data_sel*.u_ff_rd_data_sel" TNM = "TNM_RD_DATA_SEL";
#TIMESPEC "TS_MC_RD_DATA_SEL" = FROM "TNM_RD_DATA_SEL" TO FFS
#"TS_SYS_clk0" * 4;
## MUX select for read data - optional delay on data to account for byte skews
#INST "*/u_usr_rd/gen_rden_sel_mux*.u_ff_rden_sel_mux" TNM = "TNM_RDEN_SEL_MUX";
#TIMESPEC "TS_MC_RDEN_SEL_MUX" = FROM "TNM_RDEN_SEL_MUX" TO FFS
#"TS_SYS_clk0" * 4;
## Calibration/Initialization complete status flag (for PHY logic only) - can
## be used to drive both flip-flops and BRAMs
#INST "*/u_phy_init/u_ff_phy_init_data_sel" TNM = "TNM_PHY_INIT_DATA_SEL";
#TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_0" = FROM "TNM_PHY_INIT_DATA_SEL" TO FFS
#"TS_SYS_clk0" * 4;
## The RAM path is only used in cases where Write Latency (Additive Latency + 
## (CAS Latency - 1) + (1 in case of RDIMM)) is 2 or below. So these constraints are 
## valid for CAS Latency = 3, Additive Latency = 0 and selected part is not RDIMM. 
## If Write Latency is higher than 3, then a warning will appear in PAR, 
## and the constraint can be ignored as this path does not exist. RAM constraint 
## can be safely removed if the warning is not to be displayed.
#TIMESPEC "TS_MC_PHY_INIT_DATA_SEL_90" = FROM "TNM_PHY_INIT_DATA_SEL" TO RAMS
#"TS_SYS_clk0" * 4;
## Select (address) bits for SRL32 shift registers used in stage3/stage4
## calibration
#INST "*/u_phy_calib/gen_gate_dly*.u_ff_gate_dly" TNM = "TNM_GATE_DLY";
#TIMESPEC "TS_MC_GATE_DLY" = FROM "TNM_GATE_DLY" TO FFS "TS_SYS_clk0" * 4;
#
#INST "*/u_phy_calib/gen_rden_dly*.u_ff_rden_dly" TNM = "TNM_RDEN_DLY";
#TIMESPEC "TS_MC_RDEN_DLY" = FROM "TNM_RDEN_DLY" TO FFS "TS_SYS_clk0" * 4;
#
#INST "*/u_phy_calib/gen_cal_rden_dly*.u_ff_cal_rden_dly"
#  TNM = "TNM_CAL_RDEN_DLY";
#TIMESPEC "TS_MC_CAL_RDEN_DLY" = FROM "TNM_CAL_RDEN_DLY" TO FFS
#"TS_SYS_clk0" * 4;
################################################################################ 
##The following constraint is added to prevent (false) hold time violations on
##the data path from stage1 to stage2 capture flops.  Stage1 flops are clocked by 
##the delayed DQS and stage2 flops are clocked by the clk0 clock. Placing a TIG 
##on the DQ IDDR capture flop instance to achieve this is acceptable because timing
##is guaranteed through the use of separate Predictable IP constraints. These
##violations are reported when anunconstrained path report is run.	  
################################################################################ 
#INST "*/gen_dq[*].u_iob_dq/gen*.u_iddr_dq" TIG ;
################################################################################
## DQS Read Post amble Glitch Squelch circuit related constraints
################################################################################
#
################################################################################
## LOC placement of DQS-squelch related IDDR and IDELAY elements
## Each circuit can be located at any of the following locations:
##  1. Unused "N"-side of DQS differential pair I/O
##  2. DM data mask (output only, input side is free for use)
##  3. Any output-only site
################################################################################
#
################################################################################
##The following constraint is added to avoid the HOLD violations in the trace report
##when run for unconstrained paths.These two FF groups will be clocked by two different
## clocks and hence there should be no timing analysis performed on this path.
################################################################################
#INST "*/u_mem_if_top/u_phy_top/u_phy_io/u_phy_calib/gen_gate[*].u_en_dqs_ff" TNM = EN_DQS_FF;
#TIMESPEC TS_FROM_EN_DQS_FF_TO_DQ_CE_FF = FROM EN_DQS_FF TO TNM_DQ_CE_IDDR 3.85 ns DATAPATHONLY;
#
#INST "*/gen_dqs[0].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y56";
#INST "*/gen_dqs[0].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y56";
#INST "*/gen_dqs[1].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y18";
#INST "*/gen_dqs[1].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y18";
#INST "*/gen_dqs[2].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y22";
#INST "*/gen_dqs[2].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y22";
#INST "*/gen_dqs[3].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y60";
#INST "*/gen_dqs[3].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y60";
#INST "*/gen_dqs[4].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y62";
#INST "*/gen_dqs[4].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y62";
#INST "*/gen_dqs[5].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y216";
#INST "*/gen_dqs[5].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y216";
#INST "*/gen_dqs[6].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y220";
#INST "*/gen_dqs[6].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y220";
#INST "*/gen_dqs[7].u_iob_dqs/u_iddr_dq_ce"  LOC = "ILOGIC_X0Y222";
#INST "*/gen_dqs[7].u_iob_dqs/u_iodelay_dq_ce"  LOC = "IODELAY_X0Y222";
#
################################################################################
## LOC and timing constraints for flop driving DQS CE enable signal
## from fabric logic. Even though the absolute delay on this path is
## calibrated out (when synchronizing this output to DQS), the delay
## should still be kept as low as possible to reduce post-calibration
## voltage/temp variations - these are roughly proportional to the
## absolute delay of the path.                                    
##	The following code has been commented for V5 as the predictable IP will take 
##	care of placement of these flops by meeting the MAXDELAY requirement.  
##	These constraints will be removed in the next release.  
################################################################################
#
#INST "*/u_phy_calib/gen_gate[0].u_en_dqs_ff"  LOC = SLICE_X0Y28;
#INST "*/u_phy_calib/gen_gate[1].u_en_dqs_ff"  LOC = SLICE_X0Y9;
#INST "*/u_phy_calib/gen_gate[2].u_en_dqs_ff"  LOC = SLICE_X0Y11;
#INST "*/u_phy_calib/gen_gate[3].u_en_dqs_ff"  LOC = SLICE_X0Y30;
#INST "*/u_phy_calib/gen_gate[4].u_en_dqs_ff"  LOC = SLICE_X0Y31;
#INST "*/u_phy_calib/gen_gate[5].u_en_dqs_ff"  LOC = SLICE_X0Y108;
#INST "*/u_phy_calib/gen_gate[6].u_en_dqs_ff"  LOC = SLICE_X0Y110;
#INST "*/u_phy_calib/gen_gate[7].u_en_dqs_ff"  LOC = SLICE_X0Y111;
#
## Control for DQS gate - from fabric flop. Prevent "runaway" delay -
## two parts to this path: (1) from fabric flop to IDELAY, (2) from
## IDELAY to asynchronous reset of IDDR that drives the DQ CE's
## This can be relaxed by the user for lower frequencies:
## 300MHz = 850ps, 267MHz = 900ps. At 200MHz = 950ps.
## In general PAR should be able to route this
## within 900ps over all speed grades.
#NET "*/u_phy_io/en_dqs[*]" MAXDELAY = 600 ps;
#NET "*/u_phy_io/gen_dqs*.u_iob_dqs/en_dqs_sync" MAXDELAY = 800 ps;
#
################################################################################
## "Half-cycle" path constraint from IOB flip-flop to CE pin for all DQ IDDR's
## for DQS Read Post amble Glitch Squelch circuit
################################################################################
#
## Max delay from output of IOB flip-flop to CE input of DQ IDDRs =
##  tRPST + some slack where slack account for rise-time of DQS on board.
##  For now assume slack = 0.400ns (based on initial SPICE simulations,
##  assumes use of ODT), so time = 0.4*Tcyc + 0.40ns = 1.6ns @333MHz
#INST "*/gen_dqs[*].u_iob_dqs/u_iddr_dq_ce" TNM = "TNM_DQ_CE_IDDR";
#INST "*/gen_dq[*].u_iob_dq/gen_stg2_*.u_iddr_dq" TNM = "TNM_DQS_FLOPS";
#TIMESPEC "TS_DQ_CE" = FROM "TNM_DQ_CE_IDDR" TO "TNM_DQS_FLOPS" 3.6 ns;
